<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Five Forks Fire Weather</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    :root {
      --bg: #f9fafb;
      --text: #1f2937;
      --card: #ffffff;
      --border: #e5e7eb;
      --brand: #ef4444;
      --muted: #6b7280;
      --ok: #10b981;
      --warn: #f59e0b;
      --err: #ef4444;
      --shadow: 0 1px 3px rgba(0,0,0,0.1);
      --shadow-lg: 0 4px 6px -1px rgba(0,0,0,0.1);
    }
    
    [data-theme='dark'] {
      --bg: #0f172a;
      --text: #e5e7eb;
      --card: #111827;
      --border: #374151;
      --muted: #9ca3af;
    }
    
    * { box-sizing: border-box; }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      transition: background 0.3s ease, color 0.3s ease;
    }
    
    header {
      background: var(--brand);
      color: white;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      box-shadow: var(--shadow-lg);
    }
    
    h1 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .menu {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .btn, .menu a {
      appearance: none;
      background: rgba(255,255,255,0.9);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      text-decoration: none;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .btn:hover, .menu a:hover {
      background: white;
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }
    
    .btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .status-pill {
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: var(--muted);
      color: white;
    }
    
    .status-pill.ok { background: var(--ok); }
    .status-pill.warn { background: var(--warn); }
    .status-pill.error { background: var(--err); }
    
    main {
      display: grid;
      gap: 1rem;
      padding: 1rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .info-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }
    
    .cards {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      margin-bottom: 1rem;
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .card h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .weather-data {
      display: grid;
      gap: 0.5rem;
      font-size: 0.9rem;
    }
    
    .weather-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .weather-label {
      color: var(--muted);
      font-weight: 500;
    }
    
    .weather-value {
      font-weight: 600;
    }
    
    .hotspot-count {
      background: linear-gradient(135deg, var(--err), #dc2626);
      color: white;
      padding: 0.375rem 0.75rem;
      border-radius: 0.5rem;
      font-weight: 600;
      margin-top: 0.75rem;
      text-align: center;
    }
    
    .fire-flags {
      margin-top: 0.5rem;
      padding: 0.375rem 0.75rem;
      border-radius: 0.5rem;
      font-weight: 700;
      text-align: center;
      font-size: 0.8rem;
    }
    
    .fire-flags.critical {
      background: #dc2626;
      color: white;
    }
    
    .fire-flags.near-critical {
      background: #f59e0b;
      color: white;
    }
    
    .map-container {
      height: 500px;
      border-radius: 0.75rem;
      overflow: hidden;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    
    #map {
      height: 100%;
      width: 100%;
    }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: var(--muted);
    }
    
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top: 2px solid var(--brand);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .skeleton {
      background: linear-gradient(90deg, var(--border), var(--card), var(--border));
      background-size: 200px 100%;
      animation: loading 1.5s infinite;
      border-radius: 0.375rem;
    }
    
    @keyframes loading {
      0% { background-position: -200px 0; }
      100% { background-position: calc(200px + 100%) 0; }
    }
    
    footer {
      text-align: center;
      padding: 1rem;
      color: var(--muted);
      font-size: 0.875rem;
      border-top: 1px solid var(--border);
      margin-top: 2rem;
    }
    
    .error-card {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #991b1b;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
    }
    
    @media (min-width: 768px) {
      .cards {
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      }
    }
    
    @media (min-width: 1024px) {
      main {
        grid-template-columns: 2fr 1fr;
        align-items: start;
      }
      
      .map-container {
        grid-row: span 2;
        height: 600px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>🔥 Five Forks Fire Weather</h1>
    <nav class="menu">
      <button id="themeBtn" class="btn" type="button" title="Toggle theme">🌙 Theme</button>
      <button id="unitBtn" class="btn" type="button" title="Toggle °F/°C">°F</button>
      <button id="refreshBtn" class="btn" type="button" title="Refresh data">🔄 Refresh</button>
      <span id="statusPill" class="status-pill">Loading...</span>
      <span id="firePill" class="status-pill">FIRMS Loading...</span>
      <a href="https://www.weather.gov/akq/" target="_blank" rel="noopener">NWS AKQ</a>
      <a href="https://firms.modaps.eosdis.nasa.gov/" target="_blank" rel="noopener">NASA FIRMS</a>
    </nav>
  </header>

  <main>
    <div>
      <div class="info-bar">
        <div id="lastUpdated" class="weather-label">Last updated: —</div>
        <div id="extremes" class="weather-label">—</div>
      </div>
      
      <section id="cards" class="cards">
        <!-- Cards will be populated by JavaScript -->
      </section>
    </div>
    
    <div class="map-container">
      <div id="map"></div>
    </div>
  </main>

  <footer>
    <p>Data sources: NOAA National Weather Service & NASA FIRMS (via Esri) • Updates every hour</p>
    <p>Serving South-Central Virginia fire weather conditions</p>
  </footer>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    // Configuration
    const COUNTIES = [
      { name: "Amelia", lat: 37.342, lon: -77.980 },
      { name: "Nottoway", lat: 37.142, lon: -78.089 },
      { name: "Dinwiddie", lat: 37.077, lon: -77.587 },
      { name: "Prince George", lat: 37.221, lon: -77.288 },
      { name: "Brunswick", lat: 36.758, lon: -77.847 },
      { name: "Greensville", lat: 36.686, lon: -77.542 }
    ];

    // FIRMS data via Esri ArcGIS services (no API key required!)
    const FIRE_DATA_SOURCES = {
      esri_viirs: "https://services9.arcgis.com/RHVPKKiFTONKtxq3/arcgis/rest/services/Satellite_VIIRS_Thermal_Hotspots_and_Fire_Activity/FeatureServer/0/query",
      esri_modis: "https://services9.arcgis.com/RHVPKKiFTONKtxq3/arcgis/rest/services/Satellite_MODIS_Thermal_Hotspots_and_Fire_Activity/FeatureServer/0/query"
    };
    const BBOX = [-78.5, 36.4, -77.0, 37.7]; // South-Central Virginia (minLon, minLat, maxLon, maxLat)
    const REFRESH_INTERVAL = 60 * 60 * 1000; // 1 hour

    // State
    let map, mapLayers = {}, firmsCluster, isLoading = false, temperatureUnit = 'F', isDarkTheme = false;
    let lastWeatherData = null;
    let urlCache = {};

    // Utility functions
    function $(id) { return document.getElementById(id); }
    
    function saveToStorage(key, value) {
      try { localStorage.setItem(`ffwx:${key}`, JSON.stringify(value)); } catch {}
    }
    
    function getFromStorage(key) {
      try { return JSON.parse(localStorage.getItem(`ffwx:${key}`)); } catch { return null; }
    }

    function formatTemp(tempF) {
      if (typeof tempF !== 'number') return '—';
      if (temperatureUnit === 'C') {
        const tempC = Math.round((tempF - 32) * 5 / 9);
        return `${tempC}°C`;
      }
      return `${Math.round(tempF)}°F`;
    }

    function formatTimestamp(date = new Date()) {
      return date.toLocaleString(undefined, { 
        hour12: true, 
        month: 'short', 
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    }

    function updateStatusPill(status, text) {
      const pill = $('statusPill');
      pill.className = `status-pill ${status}`;
      pill.textContent = text;
    }

    function updateFireStatus(status, text) {
      const pill = $('firePill');
      if (pill) {
        pill.className = `status-pill ${status}`;
        pill.textContent = text;
      }
    }

    function parseWindMph(windStr) {
      if (!windStr) return null;
      const nums = windStr.match(/\d+/g) || [];
      return nums.length ? Math.max(...nums.map(n => parseInt(n, 10))) : null;
    }

    // Critical fire weather conditions (30/30/30 rule)
    function checkFireFlags(tempF, humidity, windStr) {
      if (!tempF || humidity == null || !windStr) return { critical: false, nearCritical: false };
      
      const tempC = (tempF - 32) * 5 / 9;
      const windMph = parseWindMph(windStr);
      
      const isCritical = tempC >= 30 && humidity <= 30 && windMph >= 18; // ~30 km/h
      const nearCritical = !isCritical && (
        (tempC >= 28 ? 1 : 0) + 
        (humidity <= 33 ? 1 : 0) + 
        (windMph >= 16 ? 1 : 0)
      ) >= 2;
      
      return { critical: isCritical, nearCritical };
    }

    // Theme management
    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      document.documentElement.dataset.theme = isDarkTheme ? 'dark' : '';
      $('themeBtn').textContent = isDarkTheme ? '☀️ Light' : '🌙 Dark';
      saveToStorage('theme', isDarkTheme);
      updateMapTheme();
    }

    function toggleUnits() {
      temperatureUnit = temperatureUnit === 'F' ? 'C' : 'F';
      $('unitBtn').textContent = `°${temperatureUnit}`;
      saveToStorage('unit', temperatureUnit);
      if (lastWeatherData) {
        renderWeatherCards(lastWeatherData);
      }
    }

    // API functions
    async function fetchWithTimeout(url, options = {}, timeout = 10000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    async function fetchWeatherData(lat, lon, name) {
      try {
        // Use cached URL if available
        let hourlyUrl = urlCache[name];
        
        if (!hourlyUrl) {
          const pointResponse = await fetchWithTimeout(`https://api.weather.gov/points/${lat},${lon}`, {
            headers: { 'Accept': 'application/geo+json' }
          });
          const pointData = await pointResponse.json();
          hourlyUrl = pointData.properties.forecastHourly;
          
          if (hourlyUrl) {
            urlCache[name] = hourlyUrl;
            saveToStorage('urlCache', urlCache);
          }
        }
        
        if (!hourlyUrl) throw new Error('No hourly forecast URL');

        // Get hourly forecast
        const forecastResponse = await fetchWithTimeout(hourlyUrl, {
          headers: { 'Accept': 'application/geo+json' }
        });
        const forecastData = await forecastResponse.json();
        
        const current = forecastData.properties.periods[0];
        if (!current) throw new Error('No current conditions');

        return {
          temperature: current.temperature,
          temperatureUnit: current.temperatureUnit,
          humidity: current.relativeHumidity?.value || null,
          dewpoint: current.dewpoint?.value || null,
          windSpeed: current.windSpeed || '—',
          windDirection: current.windDirection || '',
          wind: `${current.windSpeed || ''} ${current.windDirection || ''}`.trim(),
          shortForecast: current.shortForecast || '—',
          detailedForecast: current.detailedForecast || ''
        };
      } catch (error) {
        console.warn(`Weather fetch failed for ${name}:`, error);
        return null;
      }
    }

    async function fetchFireData() {
      const [xmin, ymin, xmax, ymax] = BBOX;
      const commonParams = {
        geometry: `${xmin},${ymin},${xmax},${ymax}`,
        geometryType: "esriGeometryEnvelope",
        inSR: "4326",
        spatialRel: "esriSpatialRelIntersects",
        outFields: "*",
        outSR: "4326",
        f: "geojson"
      };

      const seen = new Set();
      const allFeatures = [];

      // Fetch VIIRS data (past 1 day)
      try {
        const viirsParams = new URLSearchParams({ 
          ...commonParams, 
          where: "acq_date >= CURRENT_DATE - 1" 
        });
        const viirsResponse = await fetchWithTimeout(`${FIRE_DATA_SOURCES.esri_viirs}?${viirsParams}`, {}, 15000);
        const viirsData = await viirsResponse.json();
        
        if (viirsData.features) {
          viirsData.features.forEach(feature => {
            if (feature.geometry?.type === "Point") {
              const [x, y] = feature.geometry.coordinates;
              const key = `${x.toFixed(3)},${y.toFixed(3)}`;
              if (!seen.has(key)) {
                seen.add(key);
                allFeatures.push(feature);
              }
            }
          });
        }
      } catch (error) {
        console.warn('VIIRS data fetch failed:', error);
      }

      // Fetch MODIS data (past 2 days)
      try {
        const modisParams = new URLSearchParams({ 
          ...commonParams, 
          where: "acq_date >= CURRENT_DATE - 2" 
        });
        const modisResponse = await fetchWithTimeout(`${FIRE_DATA_SOURCES.esri_modis}?${modisParams}`, {}, 15000);
        const modisData = await modisResponse.json();
        
        if (modisData.features) {
          modisData.features.forEach(feature => {
            if (feature.geometry?.type === "Point") {
              const [x, y] = feature.geometry.coordinates;
              const key = `${x.toFixed(3)},${y.toFixed(3)}`;
              if (!seen.has(key)) {
                seen.add(key);
                allFeatures.push(feature);
              }
            }
          });
        }
      } catch (error) {
        console.warn('MODIS data fetch failed:', error);
      }

      console.log(`Fetched ${allFeatures.length} unique hotspots from FIRMS/Esri`);
      return {
        type: 'FeatureCollection',
        features: allFeatures
      };
    }

    // Rendering functions
    function createSkeletonCard(countyName) {
      return `
        <div class="card">
          <h3>${countyName}</h3>
          <div class="weather-data">
            <div class="skeleton" style="height: 20px; margin-bottom: 8px;"></div>
            <div class="skeleton" style="height: 20px; margin-bottom: 8px;"></div>
            <div class="skeleton" style="height: 20px; margin-bottom: 8px;"></div>
          </div>
        </div>
      `;
    }

    function createWeatherCard(county, weatherData, hotspotCount = 0) {
      const weatherIcon = getWeatherIcon(weatherData?.shortForecast);
      const dewpointText = weatherData?.dewpoint != null ? 
        (temperatureUnit === 'C' ? 
          `${Math.round(weatherData.dewpoint)}°C` : 
          `${Math.round(weatherData.dewpoint * 9/5 + 32)}°F`) : '—';
      
      const fireFlags = weatherData ? checkFireFlags(weatherData.temperature, weatherData.humidity, weatherData.wind) : { critical: false, nearCritical: false };
      
      let fireFlagsHtml = '';
      if (fireFlags.critical) {
        fireFlagsHtml = '<div class="fire-flags critical">🔥 CRITICAL: 30/30/30 CONDITIONS</div>';
      } else if (fireFlags.nearCritical) {
        fireFlagsHtml = '<div class="fire-flags near-critical">⚠️ APPROACHING 30/30/30</div>';
      }
      
      return `
        <div class="card">
          <h3>${weatherIcon} ${county.name}</h3>
          <div class="weather-data">
            <div class="weather-item">
              <span class="weather-label">Temperature:</span>
              <span class="weather-value">${weatherData ? formatTemp(weatherData.temperature) : '—'}</span>
            </div>
            <div class="weather-item">
              <span class="weather-label">Humidity:</span>
              <span class="weather-value">${weatherData?.humidity ? Math.round(weatherData.humidity) + '%' : '—'}</span>
            </div>
            <div class="weather-item">
              <span class="weather-label">Dewpoint:</span>
              <span class="weather-value">${dewpointText}</span>
            </div>
            <div class="weather-item">
              <span class="weather-label">Wind:</span>
              <span class="weather-value">${weatherData?.wind || '—'}</span>
            </div>
            <div class="weather-item">
              <span class="weather-label">Conditions:</span>
              <span class="weather-value">${weatherData?.shortForecast || '—'}</span>
            </div>
          </div>
          ${fireFlagsHtml}
          <div class="hotspot-count">
            🔥 ${hotspotCount} active hotspot${hotspotCount !== 1 ? 's' : ''} within 30km
          </div>
        </div>
      `;
    }

    function getWeatherIcon(forecast) {
      if (!forecast) return '🌤️';
      const f = forecast.toLowerCase();
      if (f.includes('thunder') || f.includes('storm')) return '⛈️';
      if (f.includes('rain') || f.includes('shower')) return '🌧️';
      if (f.includes('snow')) return '❄️';
      if (f.includes('cloud')) return '☁️';
      if (f.includes('clear') || f.includes('sunny')) return '☀️';
      if (f.includes('fog')) return '🌫️';
      return '🌤️';
    }

    function renderWeatherCards(weatherResults) {
      const cardsContainer = $('cards');
      cardsContainer.innerHTML = '';

      weatherResults.forEach((result, index) => {
        const county = COUNTIES[index];
        const hotspotCount = result?.hotspotCount || 0;
        cardsContainer.innerHTML += createWeatherCard(county, result?.weather, hotspotCount);
      });

      updateExtremes(weatherResults);
    }

    function updateExtremes(weatherResults) {
      const validData = weatherResults.filter(r => r?.weather?.temperature != null);
      if (validData.length === 0) {
        $('extremes').textContent = 'No weather data available';
        return;
      }

      const temps = validData.map(r => r.weather.temperature);
      const humidities = validData.map(r => r.weather.humidity).filter(h => h != null);
      
      const minTemp = Math.min(...temps);
      const maxTemp = Math.max(...temps);
      const minHumidity = humidities.length > 0 ? Math.min(...humidities) : null;

      const extremeParts = [];
      if (minTemp !== maxTemp) {
        extremeParts.push(`${formatTemp(minTemp)} - ${formatTemp(maxTemp)}`);
      } else {
        extremeParts.push(formatTemp(minTemp));
      }
      
      if (minHumidity !== null) {
        extremeParts.push(`RH: ${Math.round(minHumidity)}%`);
      }

      $('extremes').textContent = extremeParts.join(' • ');
    }

    // Map functions
    function initMap() {
      map = L.map('map').setView([37.1, -77.6], 8);
      
      mapLayers.light = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      });
      
      mapLayers.dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '© OpenStreetMap contributors, © CARTO'
      });

      firmsCluster = L.markerClusterGroup();
      mapLayers.counties = L.layerGroup();
      
      map.addLayer(firmsCluster);
      map.addLayer(mapLayers.counties);

      updateMapTheme();
      addCountyMarkers();

      // Layer control
      L.control.layers({}, { 
        '🔥 Fire Hotspots': firmsCluster, 
        '📍 Counties': mapLayers.counties 
      }, { collapsed: true }).addTo(map);
    }

    function updateMapTheme() {
      if (!map) return;
      
      if (isDarkTheme) {
        if (map.hasLayer(mapLayers.light)) map.removeLayer(mapLayers.light);
        if (!map.hasLayer(mapLayers.dark)) mapLayers.dark.addTo(map);
      } else {
        if (map.hasLayer(mapLayers.dark)) map.removeLayer(mapLayers.dark);
        if (!map.hasLayer(mapLayers.light)) mapLayers.light.addTo(map);
      }
    }

    function addCountyMarkers() {
      mapLayers.counties.clearLayers();
      
      COUNTIES.forEach(county => {
        const marker = L.circleMarker([county.lat, county.lon], {
          radius: 6,
          fillColor: '#3b82f6',
          color: 'white',
          weight: 2,
          opacity: 1,
          fillOpacity: 0.8
        }).bindPopup(`<strong>${county.name} County</strong><br>Weather Station`);
        
        mapLayers.counties.addLayer(marker);
      });

      // Fit map to county bounds
      const latlngs = COUNTIES.map(c => [c.lat, c.lon]);
      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds.pad(0.3));
    }

    function updateHotspots(fireData) {
      firmsCluster.clearLayers();
      
      if (fireData.features && fireData.features.length > 0) {
        L.geoJSON(fireData, {
          pointToLayer: (feature, latlng) => {
            const [lon, lat] = feature.geometry.coordinates;
            const firmsUrl = `https://firms.modaps.eosdis.nasa.gov/map/#d:24hrs;@${lon.toFixed(4)},${lat.toFixed(4)},12z`;
            const gmapsUrl = `https://www.google.com/maps?q=${lat.toFixed(5)},${lon.toFixed(5)}`;
            
            return L.circleMarker(latlng, {
              radius: 6,
              fillColor: '#ef4444',
              color: '#ef4444',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.8
            }).bindPopup(`
              🔥 Fire detected<br>
              <a href="${firmsUrl}" target="_blank" rel="noopener">FIRMS Map</a> • 
              <a href="${gmapsUrl}" target="_blank" rel="noopener">Google Maps</a>
            `);
          }
        }).addTo(firmsCluster);
      }
    }

    function countNearbyHotspots(countyLat, countyLon, hotspots, radiusKm = 30) {
      if (!hotspots.features || !window.turf) return 0;
      
      try {
        const countyPoint = turf.point([countyLon, countyLat]);
        const buffer = turf.circle(countyPoint, radiusKm, { units: 'kilometers' });
        const hotspotPoints = turf.points(hotspots.features.map(f => f.geometry.coordinates));
        const within = turf.pointsWithinPolygon(hotspotPoints, buffer);
        return within.features.length;
      } catch (error) {
        console.warn('Error counting hotspots:', error);
        return 0;
      }
    }

    // Main data refresh function
    async function refreshData() {
      if (isLoading) return;
      
      isLoading = true;
      updateStatusPill('', 'Loading...');
      updateFireStatus('', 'Loading...');
      $('refreshBtn').disabled = true;

      // Show skeleton cards
      const cardsContainer = $('cards');
      cardsContainer.innerHTML = COUNTIES.map(county => createSkeletonCard(county.name)).join('');

      try {
        // Load cached URLs
        const savedCache = getFromStorage('urlCache');
        if (savedCache) urlCache = savedCache;

        // Fetch fire data and weather data in parallel
        const [fireDataResult, ...weatherResults] = await Promise.allSettled([
          fetchFireData(),
          ...COUNTIES.map(county => fetchWeatherData(county.lat, county.lon, county.name))
        ]);

        // Handle fire data results
        let hotspotData = { type: 'FeatureCollection', features: [] };
        if (fireDataResult.status === 'fulfilled') {
          hotspotData = fireDataResult.value;
          const count = hotspotData.features.length;
          if (count > 0) {
            updateFireStatus('ok', `FIRMS: ${count} hotspots`);
          } else {
            updateFireStatus('ok', 'FIRMS: No hotspots');
          }
        } else {
          console.error('Fire data failed:', fireDataResult.reason);
          updateFireStatus('warn', 'FIRMS: Failed');
        }
        
        // Process weather results with hotspot counts
        const processedResults = weatherResults.map((result, index) => {
          const county = COUNTIES[index];
          const weather = result.status === 'fulfilled' ? result.value : null;
          const hotspotCount = countNearbyHotspots(county.lat, county.lon, hotspotData);
          
          return { weather, hotspotCount };
        });

        lastWeatherData = processedResults;
        renderWeatherCards(processedResults);
        updateHotspots(hotspotData);
        
        $('lastUpdated').textContent = `Last updated: ${formatTimestamp()}`;
        updateStatusPill('ok', 'Updated');

      } catch (error) {
        console.error('Data refresh failed:', error);
        updateStatusPill('error', 'Error');
        updateFireStatus('error', 'Error');
        $('cards').innerHTML = '<div class="error-card">Failed to load weather data. Please try refreshing.</div>';
      } finally {
        isLoading = false;
        $('refreshBtn').disabled = false;
      }
    }

    // Initialize app
    function initApp() {
      // Load saved preferences
      const savedTheme = getFromStorage('theme');
      const savedUnit = getFromStorage('unit');
      
      if (savedTheme) {
        isDarkTheme = savedTheme;
        document.documentElement.dataset.theme = isDarkTheme ? 'dark' : '';
        $('themeBtn').textContent = isDarkTheme ? '☀️ Light' : '🌙 Dark';
      }
      
      if (savedUnit) {
        temperatureUnit = savedUnit;
        $('unitBtn').textContent = `°${temperatureUnit}`;
      }

      // Set up event listeners
      $('themeBtn').addEventListener('click', toggleTheme);
      $('unitBtn').addEventListener('click', toggleUnits);
      $('refreshBtn').addEventListener('click', refreshData);

      // Initialize map and load initial data
      initMap();
      refreshData();

      // Set up auto-refresh
      setInterval(refreshData, REFRESH_INTERVAL);
    }

    // Start the app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>
</body>
</html>
